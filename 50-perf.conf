###################################################################
# Arquivo sysctl.conf unificado
###################################################################

#######################
### OPÇÕES GERAIS   ###
#######################

# Número máximo de arquivos que podem ser atribuídos a um único processo
fs.nr_open = 2147483584

# Número máximo de solicitações de E/S assíncronas
fs.aio-max-nr = 18446744073709551615

# Permitir mais PIDs
kernel.pid_max = 4194304

# Controla o tamanho máximo de uma mensagem, em bytes
kernel.msgmni = 16384
kernel.msgmax = 65535
kernel.msgmnb = 65535

# Parâmetros de semáforos
kernel.sem = 32000 1024000000 500 32000

# Definir a quantidade máxima de memória alocada para shm
kernel.shmall = 4294967296
kernel.shmmax = 68719476736
kernel.shmmni = 4096

# Desativar atalhos de teclado SysRq (não somos um computador desktop)
kernel.sysrq = 0

# Proteger links físicos/simbólicos do sistema
fs.protected_hardlinks = 1
fs.protected_symlinks = 1

# Grande aumento de desempenho (publicado pela comunidade PostgreSQL)
kernel.sched_migration_cost_ns = 5000000
kernel.sched_autogroup_enabled = 0

# Restringir dumps de núcleo
fs.suid_dumpable = 0

# Ocultar ponteiros de kernel expostos
kernel.kptr_restrict = 1

# Restringir acesso aos logs do kernel
kernel.dmesg_restrict = 1

# Restringir o escopo do ptrace
kernel.yama.ptrace_scope = 1

# Ativar proteção ExecShield
kernel.exec-shield = 1
kernel.randomize_va_space = 2

# Os conteúdos de /proc/<pid>/maps e smaps são visíveis apenas para leitores que podem usar ptrace() no processo
kernel.maps_protect = 1

# Anexar PID ao nome do arquivo core dump
kernel.core_uses_pid = 1

# Aumentar o tamanho dos identificadores de arquivo e do cache de inode
fs.file-max = 2097152

#########################
### GESTÃO DE MEMÓRIA ###
#########################

# Fazer menos swapping
vm.swappiness = 10

# Taxas de dirty
vm.dirty_ratio = 50
vm.dirty_background_ratio = 5
vm.dirty_expire_centisecs = 1400

# Manter pelo menos 64 MB de espaço livre de RAM disponível
vm.min_free_kbytes = 65535

# Desativar a recuperação de memória quando uma zona fica sem memória.
vm.zone_reclaim_mode = 0

# Número máximo de Áreas de Memória Virtual (VMAs) que um processo pode possuir
vm.max_map_count = 2147483647

# Reduzir pesquisas no sistema de arquivos
vm.vfs_cache_pressure = 50

# Evitar mensagens de aviso do Redis
vm.overcommit_memory = 1

# Especifica o endereço virtual mínimo que um processo pode mapear com mmap
vm.mmap_min_addr = 4096

# 50% de overcommitment da memória disponível
vm.overcommit_ratio = 50

###########################
### DESEMPENHO DE REDE ###
###########################

# Controle de Congestionamento BBR (kernel > 4.9)
# Faça um 'sudo modprobe tcp_bbr' primeiro
net.ipv4.tcp_congestion_control = bbr
net.ipv4.tcp_notsent_lowat = 16384
net.core.default_qdisc = fq

# =============================================================================
# BUSY POLLING - Reduz latência em ~5-10% (Extreme HTTP Performance Tuning)
# =============================================================================
# Permite polling ativo do socket quando não há eventos, reduzindo latência
# Valor baixo (1μs) minimiza overhead de CPU enquanto mantém benefícios
# Ref: https://talawah.io/blog/extreme-http-performance-tuning-one-point-two-million/
net.core.busy_poll = 1
net.core.busy_read = 1

# Fila máxima de conexões pendentes aguardando para serem aceitas.
net.core.somaxconn = 32768

# Faixa de porta local permitida
net.ipv4.ip_local_port_range = 1024 65535

# Ativar spoof protection (filtros de caminho reverso)
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.rp_filter = 1
net.ipv6.conf.default.rp_filter = 1
net.ipv6.conf.all.rp_filter = 1

# Desativar encaminhamento de pacotes (mantém SLAAC = Autoconfiguração de Endereço Sem Estado)
net.ipv4.ip_forward = 0
net.ipv6.conf.all.forwarding = 0

# Não aceitar redirecionamentos ICMP (evita ataques MITM)
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.accept_redirects = 0
net.ipv6.conf.default.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0

# Não enviar redirecionamentos ICMP (não somos um roteador ... suporta apenas IPv4)
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.send_redirects = 0

# Não aceitar pacotes de rota de origem IP (não somos um roteador)
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv6.conf.default.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0

# Faixa de porta local permitida (definida para o limite máximo)
net.ipv4.ip_local_port_range = 1024 65535
net.ipv6.ip_local_port_range = 1024 65535

# Registrar pacotes Martian (suporta apenas IPv4)
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1

# Ativar cookies TCP/IP SYN (proteção contra inundação SYN)
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.tcp_synack_retries = 2

# Número máximo de soquetes TCP não anexados a nenhum identificador de arquivo de usuário (mantidos pelo sistema)
net.ipv4.tcp_max_orphans = 16384

# Desativar início lento TCP (não somos uma WAN de velocidade variável)
net.ipv4.tcp_slow_start_after_idle = 0

# Proteger contra TCP Time-Wait (assassinar!)
net.ipv4.tcp_rfc1337 = 1

# Diminuir o valor padrão de tempo limite para conexão tcp_fin_timeout (copiado do EasyEngine)
net.ipv4.tcp_fin_timeout = 7

# Diminuir os tempos limite de conexão keepalive (copiado do EasyEngine)
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_intvl = 15

# Janela inicial de recebimento TCP (fallback para rotas sem initrwnd; aplica a IPv4/IPv6)
net.ipv4.tcp_default_init_rwnd = 30

# Aumentar o espaço de buffer de leitura alocável (copiado do EasyEngine)
net.ipv4.tcp_rmem = 8192 87380 16777216
net.ipv4.udp_rmem_min = 16384

# Aumentar o espaço de buffer de gravação alocável (copiado do EasyEngine)
net.ipv4.tcp_wmem = 8192 65536 16777216
net.ipv4.udp_wmem_min = 16384

# FIN-WAIT: fecha sockets mortos mais rápido (padrão: 60s)
net.ipv4.tcp_fin_timeout = 10

# Limite de half-open connections (SYN queue)
net.ipv4.tcp_max_syn_backlog = 2048

# RST para conexões que chegam com backlog cheio (em vez de silêncio)
net.ipv4.tcp_abort_on_overflow = 1

# Aumentar o tamanho do pool de buckets tcp-time-wait para evitar ataques DOS simples (copiado do EasyEngine)
net.ipv4.tcp_max_tw_buckets = 1440000
net.ipv4.tcp_tw_reuse = 1

# Backlog de conexões de entrada
net.core.netdev_max_backlog = 16384

# Configurações de wmem
net.core.wmem_default = 31457280
net.core.wmem_max = 16777216

# Configurações de rmem
net.core.rmem_default = 31457280
net.core.rmem_max = 16777216

# Configurações de memória de opção (copiado do EasyEngine)
net.core.optmem_max = 25165824

# Configurações de orçamento netdev
net.core.netdev_budget = 50000
net.core.netdev_budget_usecs = 5000

# Endurecer o compilador BPF JIT
net.core.bpf_jit_harden = 1

# Não retransmitir bootp
net.ipv4.conf.all.bootp_relay = 0

# Não fazer proxy arp para ninguém
net.ipv4.conf.all.proxy_arp = 0

# Ativar o tcp_timestamps, o timestamp preciso faz os algoritmos de controle de congestionamento TCP funcionarem melhor
net.ipv4.tcp_timestamps = 1

# Não ignorar pings direcionados
net.ipv4.icmp_echo_ignore_all = 0

# Ativar ignorar solicitações de broadcasts
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Ativar proteção contra mensagens de erro inválidas
net.ipv4.icmp_ignore_bogus_error_responses = 1

# Ativar uma correção para RFC1337 - riscos de assassinato de tempo de espera em TCP
net.ipv4.tcp_rfc1337 = 1

# Ativar o tcp_window_scaling
net.ipv4.tcp_window_scaling = 1

# Aumentar o número de conexões de entrada
net.core.somaxconn = 32768

# Aumentar o número de backlog de conexões de entrada
net.core.netdev_max_backlog = 16384
net.core.dev_weight = 64
net.core.netdev_budget = 1200
net.core.netdev_budget_usecs = 8000

# Aumentar a quantidade máxima de buffers de memória de opção
net.core.optmem_max = 65535

# Aumentar o tamanho do pool de buckets tcp-time-wait para evitar ataques DOS simples
net.ipv4.tcp_max_tw_buckets = 1440000

# Tentar reutilizar conexões time-wait, mas não reciclá-las (reciclar pode quebrar clientes atrás de NAT)
net.ipv4.tcp_tw_reuse = 1

# Limitar o número de órfãos, cada órfão pode consumir até 16M (máximo wmem) de memória não trocável
net.ipv4.tcp_max_orphans = 16384
net.ipv4.tcp_orphan_retries = 0

# Limitar a memória máxima usada para remontar fragmentos de IP (CVE-2018-5391)
net.ipv4.ipfrag_low_thresh = 196608
net.ipv6.ip6frag_low_thresh = 196608
net.ipv4.ipfrag_high_thresh = 262144
net.ipv6.ip6frag_high_thresh = 262144

# Não armazenar em cache ssthresh da conexão anterior
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_moderate_rcvbuf = 1

# Aumentar o tamanho do comprimento da fila de datagramas RPC
net.unix.max_dgram_qlen = 50

# =============================================================================
# ARP CACHE TUNING - Reduz overhead de rede (Extreme HTTP Performance Tuning)
# =============================================================================
# Ajustes para reduzir a frequência de refreshes de ARP e overhead de rede
# Ref: https://talawah.io/blog/extreme-http-performance-tuning-one-point-two-million/

# Não permitir que a tabela arp se torne maior que isso
net.ipv4.neigh.default.gc_thresh3 = 2048

# Dizer ao gc quando se tornar agressivo com a limpeza da tabela arp.
# Ajustar isso com base no tamanho da LAN. 1024 é adequado para a maioria das redes /24
net.ipv4.neigh.default.gc_thresh2 = 1024

# Ajustar onde o gc deixará a tabela arp em paz - aumentado de 32 para 128
# Valor maior = menos operações de GC em ambientes estáveis
net.ipv4.neigh.default.gc_thresh1 = 128

# Aumentar intervalo de GC de 30s para 300s (5 min) - menos overhead
net.ipv4.neigh.default.gc_interval = 300

# Tempo antes de considerar entrada ARP como stale (5 min)
net.ipv4.neigh.default.gc_stale_time = 300

# Aumentar o comprimento da fila TCP
net.ipv4.neigh.default.proxy_qlen = 96
net.ipv4.neigh.default.unres_qlen = 6

# Ativar a Notificação Explícita de Congestionamento (RFC 3168), desativá-la se não funcionar para você
net.ipv4.tcp_ecn = 1
net.ipv4.tcp_reordering = 3

# Quantas vezes tentar matar uma conexão TCP viva
net.ipv4.tcp_retries2 = 15
net.ipv4.tcp_retries1 = 3

# Evitar voltar ao início lento após uma conexão ficar ociosa
# Mantém nosso cwnd grande com as conexões keep alive (kernel > 3.6)
net.ipv4.tcp_slow_start_after_idle = 0

# Permitir que o sinalizador TCP fastopen seja usado, cuidado, alguns firewalls não gostam de TFO! (kernel > 3.7)
net.ipv4.tcp_fastopen = 3

# Isso garantirá que as conexões subsequentes imediatas usem os novos valores
net.ipv4.route.flush = 1
net.ipv6.route.flush = 1