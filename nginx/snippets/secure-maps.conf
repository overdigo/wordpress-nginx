# ============================================================================
# SECURITY MAPS - Include in http context (nginx.conf)
# Performance optimized: maps are evaluated once at hash time
# ============================================================================

# Cookie Security - XSS Patterns
map $http_cookie $bad_cookie_xss {
    default 0;
    "~*(<|%3C).*script.*(>|%3E)" 1;
    "~*(javascript|vbscript)(\s*:|%3A)" 1;
    "~*(document\.(cookie|write|location)|window\.(location|open))" 1;
    "~*(eval|alert|confirm|prompt)\s*\(" 1;
}

# Cookie Security - SQL Injection Patterns
map $http_cookie $bad_cookie_sqli {
    default 0;
    "~*\b(UNION\s+(ALL\s+)?SELECT|SELECT\s+.*\s+FROM)\b" 1;
    "~*\b(DROP\s+(TABLE|DATABASE)|TRUNCATE\s+TABLE)\b" 1;
    "~*\b(SLEEP\s*\(|WAITFOR\s+DELAY|BENCHMARK\s*\()\b" 1;
    "~*\b(LOAD_FILE|INTO\s+(OUT|DUMP)FILE)\b" 1;
}

# Cookie Security - Encoding Attacks (only dangerous ones)
map $http_cookie $bad_cookie_encoding {
    default 0;
    # CRLF injection
    "~*(%0d%0a|%0D%0A)" 1;
    # Null byte
    "~*(%00|\x00)" 1;
}

# Cookie Security - Overflow (8KB max)
map $http_cookie $bad_cookie_overflow {
    default 0;
    "~*^.{8192,}$" 1;
}

# Cookie Security - Too many cookies (DoS protection, max 50)
map $http_cookie $bad_cookie_count {
    default 0;
    # More than 50 cookie separators (;) is suspicious
    "~*(;.*){50,}" 1;
}

# Query String Security - XSS Patterns
map $query_string $bad_query_xss {
    default 0;
    # Script tags
    "~*(<|%3C).*script.*(>|%3E)" 1;
    # Pseudo-protocols
    "~*(javascript|vbscript)(\s*:|%3A)" 1;
    # Event handlers
    "~*(onload|onerror|onclick|onmouseover|onfocus|onblur|onsubmit|onchange)\s*=" 1;
    # Common XSS payloads
    "~*\balert\s*\(" 1;
    "~*\b(document\.cookie|document\.domain|document\.write)\b" 1;
    "~*\b(window\.location|location\.href)\s*=" 1;
}

# Query String Security - SQL Injection Patterns
map $query_string $bad_query_sqli {
    default 0;
    # Classic injection patterns
    "~*('|%27|\"|%22)\s*(OR|AND)\s*('|%27|\"|%22)\d+('|%27|\"|%22)\s*=\s*('|%27|\"|%22)\d+" 1;
    # DDL/DML operations
    "~*\b(DROP|TRUNCATE|ALTER|CREATE)\s+(TABLE|DATABASE|INDEX|VIEW)\b" 1;
    "~*\b(INSERT\s+INTO.*VALUES)\b" 1;
    "~*\b(UPDATE.*SET)\b" 1;
    "~*\b(DELETE\s+FROM)\b" 1;
    # Union based
    "~*\b(UNION\s*(ALL\s+)?SELECT)\b" 1;
    "~*\b(SELECT\s+.*\s+FROM)\b" 1;
    # Time-based injection
    "~*\b(SLEEP|BENCHMARK|PG_SLEEP|DBMS_LOCK\.SLEEP)\s*\(" 1;
    "~*\bWAITFOR\s+(DELAY|TIME)\b" 1;
    # Boolean-based injection
    "~*(\bAND\b|\bOR\b)\s+\d+\s*[<>=!]+\s*\d+" 1;
    "~*(\bAND\b|\bOR\b)\s+(TRUE|FALSE|NULL)\b" 1;
    # Conditional functions
    "~*(CASE\s+WHEN|IF\s*\(.*,.*,.*\)|IFNULL|NULLIF|COALESCE)\s*\(" 1;
    # SQL comments (used to bypass filters)
    "~*(--|%23|#|/\*|\*/)" 1;
    # Hex encoding (0x prefix for data)
    "~*0x[0-9a-f]{2,}" 1;
}

# Query String Security - LFI Patterns
map $query_string $bad_query_lfi {
    default 0;
    # Linux system directories
    "~*/var/(log|www|tmp|lib|run|spool)/" 1;
    # Linux system files
    "~*(/etc/passwd|/etc/shadow|/etc/group|/etc/hosts)" 1;
    # Linux process/shell access
    "~*(/proc/self|/proc/version|/bin/sh|/bin/bash|/usr/bin)" 1;
    # PHP wrappers and stream protocols
    "~*(expect|phar|zip|zlib|ssh2|rar|ogg|glob|php|data|input|filter)://" 1;
    # Windows system files and directories
    "~*(\\\\|%5c|%5C)(windows|winnt|system32|boot\\.ini|web\\.config)" 1;
    "~*(win\\.ini|boot\\.ini|windows/system32)" 1;
    # Drive letter access
    "~*[a-zA-Z]:(\\\\|%5c|%5C|/)" 1;
    # Directory traversal patterns
    "~*(\\.\\./|\\.\\.\\\\)" 1;
    "~*(%2e%2e%2f|%2e%2e/|\\.\\.%2f|%2e%2e%5c)" 1;
}

# Query String Security - RFI Patterns
map $query_string $bad_query_rfi {
    default 0;
    "~*(^|[?&=])(https?|ftps?)(%3a|:)(%2f|/){2}[^/\s]*\.(txt|php|inc|asp|jsp|pl|py|sh|bash|exe|dll)" 1;
    "~*(%68%74%74%70|%48%54%54%50)(%3a|%3A)(%2f|%2F){2}" 1;
    "~*(%25%36%38%25%37%34%25%37%34%25%37%30|%2568%2574%2574%2570)" 1;
    "~*=\s*(https?|ftps?|gopher)://[^/]+\.[^/]+/" 1;
}

# Query String Security - Command Injection Patterns
map $query_string $bad_query_cmdi {
    default 0;
    "~*(;|%3b|%3B)\s*(id|whoami|uname|cat|ls|pwd|wget|curl|nc|bash|sh|python|perl|ruby|php)\b" 1;
    "~*(\||%7c|%7C)\s*(id|whoami|uname|cat|ls|pwd|wget|curl|nc|bash|sh)\b" 1;
    "~*(\|\||%7c%7c|%7C%7C)\s*(id|whoami|uname|cat|ls|pwd|wget|curl|nc|bash|sh)\b" 1;
    "~*(\&\&|%26%26)\s*(id|whoami|uname|cat|ls|pwd|wget|curl|nc|bash|sh)\b" 1;
    "~*(\$\(|%24%28|%24\()" 1;
    "~*\b(curl|wget|lwp-download|fetch)\s+(-[a-zA-Z]*\s+)*(https?|ftps?|gopher)://" 1;
    "~*\bnc\s+(-[a-zA-Z]*\s+)*(\d{1,3}\.){3}\d{1,3}\s+\d+" 1;
    "~*\b(nc|netcat|ncat)\s+(-[a-zA-Z]*\s+)*(localhost|127\.0\.0\.1|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})" 1;
    "~*(;|&&|\|\||%3b|%26%26|%7c%7c)\s*\w+\s*" 1;
}

# Args Security - Dangerous Functions
map $args $bad_args {
    default 0;
    "~*(eval|base64_encode|base64_decode)\s*\(" 1;
}

# ============================================================================
# PHP ATTACKS PROTECTION
# ============================================================================

# PHP Code Injection - Dangerous functions in query string
map $query_string $bad_php_code {
    default 0;
    # eval() and variants
    "~*\beval\s*\(" 1;
    "~*\bassert\s*\(" 1;
    # preg_replace with /e modifier (code execution)
    "~*preg_replace\s*\(.*/.*/.*e" 1;
    # create_function (deprecated but still exploitable)
    "~*\bcreate_function\s*\(" 1;
    # System execution functions
    "~*\b(system|passthru|exec|shell_exec|popen|proc_open)\s*\(" 1;
    # Backtick execution (already covered but explicit here)
    "~*`[^`]+`" 1;
}

# PHP Deserialization Gadgets - Common gadget chain patterns
map $query_string $bad_php_serialize {
    default 0;
    # Serialized object patterns (O: object, C: custom object)
    "~*[OC]:\d+:\"[^\"]+\":\d+:\{" 1;
    # Serialized array with suspicious class names
    "~*a:\d+:\{.*[OC]:\d+:" 1;
    # Common gadget chain classes
    "~*(Monolog|Guzzle|Swift_|Symfony|Laravel|Illuminate|Carbon|League|Doctrine)" 1;
    # PHPUnit gadget
    "~*PHPUnit" 1;
    # __wakeup, __destruct exploitation markers
    "~*(__wakeup|__destruct|__toString|__call)" 1;
}

# PHP Code in Args (POST/GET parameters)
map $args $bad_args_php {
    default 0;
    # PHP code injection patterns
    "~*<\?php" 1;
    "~*<\?=" 1;
    # eval and assert
    "~*\beval\s*\(" 1;
    "~*\bassert\s*\(" 1;
    # preg_replace /e
    "~*preg_replace.*/.*/e" 1;
    # Variable functions
    "~*\$\{.*\}" 1;
    "~*\$_?(GET|POST|REQUEST|COOKIE|SERVER|FILES|ENV)\s*\[" 1;
}

# Combined PHP attacks check
map "$bad_php_code$bad_php_serialize$bad_args_php" $bad_php {
    default 0;
    "~*1" 1;
}

# ============================================================================
# LDAP INJECTION PROTECTION
# DISABLED: Too aggressive for WordPress - causes false positives
# Enable only if you have an LDAP-connected application
# ============================================================================

# LDAP Injection patterns in query string
map $query_string $bad_ldap_injection {
    default 0;
    # DISABLED - blocks normal URL characters like () and &
    # "~*[()\\*\\|&!]" 1;
    # "~*(\\|\\(|\\)\\(|\\(\\||\\*\\)|\\)\\*)" 1;
    # "~*\\(\\|\\(.*=\\*\\)" 1;
    # "~*\\(&\\(.*=\\*\\)" 1;
    # "~*(uid|cn|sn|mail|objectClass)\\s*=" 1;
    "~*%00" 1;
}

# LDAP Injection in URI
map $request_uri $bad_ldap_uri {
    default 0;
    # DISABLED
    # "~*\\(\\|\\(" 1;
    # "~*\\)\\(" 1;
    # "~*\\*\\)" 1;
}

# Combined LDAP check
map "$bad_ldap_injection$bad_ldap_uri" $bad_ldap {
    default 0;
    "~*1" 1;
}

# ============================================================================
# NOSQL INJECTION PROTECTION (MongoDB, CouchDB, etc.)
# Only for sites using MongoDB/CouchDB - safe patterns only
# ============================================================================

# NoSQL Injection patterns in query string
map $query_string $bad_nosql_query {
    default 0;
    # MongoDB JavaScript injection (specific enough to be safe)
    "~*\\$where\\s*:" 1;
    # DISABLED - too broad
    # "~*\\$(where|gt|gte|lt|lte|ne|in|nin|or|and|not|nor|exists|type|mod|regex|text|all|elemMatch|size|slice)" 1;
    # "~*function\\s*\\(" 1;
    # "~*\\{\\s*[\"']?\\$" 1;
    # "~*_all_docs" 1;
    # "~*_design" 1;
    # "~*_view" 1;
}

# NoSQL Injection in request body indicators (via URI encoding)
map $request_uri $bad_nosql_uri {
    default 0;
    "~*%24where" 1;
    # DISABLED
    # "~*%24(where|gt|lt|ne|or|and|regex)" 1;
    # "~*%7b.*%24" 1;
}

# Combined NoSQL check
map "$bad_nosql_query$bad_nosql_uri" $bad_nosql {
    default 0;
    "~*1" 1;
}

# ============================================================================
# HTTP PARAMETER POLLUTION (HPP) PROTECTION
# DISABLED: Causes false positives with legitimate WordPress URLs
# ============================================================================

# HPP Detection - Multiple same parameters
map $query_string $bad_hpp {
    default 0;
    # DISABLED - too aggressive
    # "~*(^|&)(id|user|admin|pass|token|session|key)=[^&]*(\\&\\1=)" 1;
    # "~*\\[\\]=[^&]*\\[\\]=" 1;
    # "~*(&[^=]+=[^&]*){10,}" 1;
}

# ============================================================================
# FORMAT STRING INJECTION PROTECTION
# DISABLED: Causes false positives with URL-encoded characters
# ============================================================================

# Format string patterns
map $query_string $bad_format_string {
    default 0;
    # DISABLED - blocks %20, %3d, etc in normal URLs
    # "~*%[0-9]*[diouxXeEfFgGaAcspn]" 1;
    # Only keep very specific attack patterns
    "~*%n%n%n" 1;
    "~*AAAA%08x" 1;
}

# ============================================================================
# SESSION FIXATION PROTECTION
# ============================================================================

# Session ID in URL (Session Fixation attacks)
map $request_uri $bad_session_fixation {
    default 0;
    # PHP session ID in URL
    "~*(phpsessid|phpsessionid)=" 1;
    # Java session ID in URL
    "~*jsessionid=" 1;
    # ASP session ID in URL
    "~*(aspsessionid|asp\.net_sessionid)=" 1;
    # Generic session patterns
    "~*(session_id|sess_id|sid)=[a-f0-9]{16,}" 1;
}

# ============================================================================
# JAVA CODE INJECTION PROTECTION
# ============================================================================

# Java/OGNL Injection patterns
map $request_uri $bad_java_injection {
    default 0;
    # Java runtime calls
    "~*java\\.lang" 1;
    "~*runtime\\.exec" 1;
    "~*javax\\.script" 1;
    # OGNL injection (Struts vulnerability)
    "~*%23(cmd|context|request|session|application)" 1;
    "~*\\$\\{.*java" 1;
    # Log4j JNDI injection (CVE-2021-44228)
    "~*\\$\\{jndi:" 1;
    "~*%24%7bjndi:" 1;
    "~*\\$\\{\\$\\{" 1;
}

# Java injection in query string
map $query_string $bad_java_query {
    default 0;
    "~*java\\.lang" 1;
    "~*runtime\\.exec" 1;
    "~*javax\\.script" 1;
    "~*\\$\\{jndi:" 1;
    "~*%24%7bjndi:" 1;
}

# Combined Java injection check
map "$bad_java_injection$bad_java_query" $bad_java {
    default 0;
    "~*1" 1;
}

# ============================================================================
# SHELLSHOCK PROTECTION (CVE-2014-6271)
# ============================================================================

# Shellshock patterns in User-Agent
map $http_user_agent $bad_shellshock_ua {
    default 0;
    # Classic Shellshock signature
    "~*\\(\\)\\s*\\{\\s*;" 1;
    # Bash function definition pattern
    "~*\\(\\)\\s*\\{\\s*:" 1;
    # Encoded variants
    "~*%28%29%20%7b" 1;
}

# Shellshock patterns in Referer
map $http_referer $bad_shellshock_referer {
    default 0;
    "~*\\(\\)\\s*\\{\\s*;" 1;
    "~*\\(\\)\\s*\\{\\s*:" 1;
}

# Shellshock patterns in Cookie
map $http_cookie $bad_shellshock_cookie {
    default 0;
    "~*\\(\\)\\s*\\{\\s*;" 1;
    "~*\\(\\)\\s*\\{\\s*:" 1;
}

# Shellshock patterns in Accept-Language
map $http_accept_language $bad_shellshock_lang {
    default 0;
    "~*\\(\\)\\s*\\{\\s*;" 1;
}

# Combined Shellshock check
map "$bad_shellshock_ua$bad_shellshock_referer$bad_shellshock_cookie$bad_shellshock_lang" $bad_shellshock {
    default 0;
    "~*1" 1;
}

# ============================================================================
# SECURITY SCANNER / MALICIOUS BOT DETECTION
# ============================================================================

# Known vulnerability scanners and pentest tools
map $http_user_agent $bad_scanner {
    default 0;
    # Vulnerability scanners
    "~*(nikto|nessus|openvas|nexpose|qualys|acunetix)" 1;
    # Web application scanners
    "~*(sqlmap|havij|pangolin|jsql)" 1;
    "~*(burp|paros|owasp|zap|w3af)" 1;
    "~*(netsparker|appscan|webinspect|arachni)" 1;
    # Network scanners and enumeration tools
    "~*(nmap|masscan|zgrab|gobuster|dirbuster|dirb|wfuzz)" 1;
    "~*(hydra|medusa|brutus)" 1;
    # Exploit frameworks
    "~*(metasploit|beef|cobalt)" 1;
    # Shell injection indicators in UA
    "~*(bash|cmd\\.exe|powershell)" 1;
}

# Suspicious generic user agents (empty or very short)
map $http_user_agent $bad_ua_generic {
    default 0;
    # Empty user agent
    "" 1;
    # Single character or very short
    "~*^.{1,3}$" 1;
    # Common malicious patterns
    "~*^(-|\\.|test|scanner|bot)$" 1;
}

# Combined Scanner/Bot check
map "$bad_scanner$bad_ua_generic" $bad_scanner_bot {
    default 0;
    "~*1" 1;
}

# ============================================================================
# HTTPOXY PROTECTION (CVE-2016-5385)
# ============================================================================

# HTTPoxy - Proxy header from client (should not exist)
# Note: The actual mitigation is in fastcgi.conf (HTTP_PROXY = "")
# This map is for logging/detection purposes
map $http_proxy $bad_httpoxy {
    default 0;
    # Any value in Proxy header is suspicious
    "~*.+" 1;
}

# ============================================================================
# HEADER INJECTION PROTECTION
# ============================================================================

# CRLF Injection in common headers
map $http_referer $bad_header_crlf_referer {
    default 0;
    "~*(%0d|%0a|%0D|%0A|\r|\n)" 1;
}

map $http_user_agent $bad_header_crlf_ua {
    default 0;
    "~*(%0d|%0a|%0D|%0A|\r|\n)" 1;
}

map $http_accept $bad_header_crlf_accept {
    default 0;
    "~*(%0d|%0a|%0D|%0A|\r|\n)" 1;
}

map $http_accept_language $bad_header_crlf_lang {
    default 0;
    "~*(%0d|%0a|%0D|%0A|\r|\n)" 1;
}

map $http_accept_encoding $bad_header_crlf_enc {
    default 0;
    "~*(%0d|%0a|%0D|%0A|\r|\n)" 1;
}

# Combined CRLF check
map "$bad_header_crlf_referer$bad_header_crlf_ua$bad_header_crlf_accept$bad_header_crlf_lang$bad_header_crlf_enc" $bad_header_crlf {
    default 0;
    "~*1" 1;
}

# Header Override Attacks - X-Forwarded-Host
# DISABLED: Proxies and CDNs legitimately use this header
# Only enable if you don't use a reverse proxy
map $http_x_forwarded_host $bad_header_xfh {
    default 0;
    # "~*.+" 1;
}

# Header Override Attacks - X-Forwarded-Proto manipulation
# DISABLED: Proxies and CDNs legitimately use this header
map $http_x_forwarded_proto $bad_header_xfp {
    default 0;
    # "~*^http$" 1;
}

# Header Override Attacks - X-Original-URL (URL rewrite bypass)
# Keep enabled as this is used for bypass attacks
map $http_x_original_url $bad_header_xou {
    default 0;
    "~*.+" 1;
}

# Header Override Attacks - X-Rewrite-URL (URL rewrite bypass)
# Keep enabled as this is used for bypass attacks
map $http_x_rewrite_url $bad_header_xru {
    default 0;
    "~*.+" 1;
}

# Header Override Attacks - X-HTTP-Method-Override (method tampering)
# DISABLED: Some frameworks use this legitimately
map $http_x_http_method_override $bad_header_method_override {
    default 0;
    # "~*^(DELETE|PUT|TRACE|CONNECT|OPTIONS|PATCH)$" 1;
}

# Header Override Attacks - X-Method-Override variant
# DISABLED: Some frameworks use this legitimately
map $http_x_method_override $bad_header_method_override2 {
    default 0;
    # "~*^(DELETE|PUT|TRACE|CONNECT|OPTIONS|PATCH)$" 1;
}

# Combined Header Override check
map "$bad_header_xfh$bad_header_xfp$bad_header_xou$bad_header_xru$bad_header_method_override$bad_header_method_override2" $bad_header_override {
    default 0;
    "~*1" 1;
}

# Malicious Payloads in User-Agent header
map $http_user_agent $bad_header_ua_payload {
    default 0;
    # SQL Injection
    "~*('|\")\s*(OR|AND|UNION|SELECT|DROP|INSERT|UPDATE|DELETE)\b" 1;
    "~*\b(UNION\s+SELECT|SELECT\s+FROM|DROP\s+TABLE)\b" 1;
    # XSS
    "~*(<|%3C).*script.*(>|%3E)" 1;
    "~*(javascript|vbscript|expression):" 1;
    "~*(onload|onerror|onclick|onmouseover)\s*=" 1;
    # Null byte
    "~*(%00|\x00)" 1;
    # Path traversal
    "~*(\.\.\/|\.\.\\\\|%2e%2e%2f|%2e%2e\/|\.\.%2f|%2e%2e%5c)" 1;
    # Command injection  
    "~*(;|\||&&)\s*(cat|ls|id|whoami|wget|curl|nc|bash|sh|python|perl)\b" 1;
    "~*(\$\(|`)[^`\)]*\b(cat|ls|id|whoami|wget|curl)\b" 1;
    # Template injection (SSTI)
    "~*(\{\{|\$\{|\#{|<%|%>)" 1;
}

# Malicious Payloads in Referer header
map $http_referer $bad_header_referer_payload {
    default 0;
    # SQL Injection
    "~*('|\")\s*(OR|AND|UNION|SELECT|DROP)\b" 1;
    # XSS
    "~*(<|%3C).*script.*(>|%3E)" 1;
    "~*(javascript|vbscript):" 1;
    # Null byte
    "~*(%00|\x00)" 1;
    # Path traversal
    "~*(\.\.\/|\.\.\\\\|%2e%2e%2f)" 1;
    # Command injection
    "~*(;|\||&&)\s*(cat|ls|id|whoami|wget|curl|nc|bash|sh)\b" 1;
    # Template injection
    "~*(\{\{|\$\{|\#{|<%)" 1;
}

# Combined Payload check
map "$bad_header_ua_payload$bad_header_referer_payload" $bad_header_payload {
    default 0;
    "~*1" 1;
}

# Final Header security check
map "$bad_header_crlf$bad_header_override$bad_header_payload" $bad_header {
    default 0;
    "~*1" 1;
}

# ============================================================================
# CONTENT-TYPE ATTACKS PROTECTION
# ============================================================================

# XXE and XML Attacks - Block dangerous XML Content-Types
map $content_type $bad_ct_xxe {
    default 0;
    # SOAP injection attempts (unusual for WordPress)
    "~*application/soap\+xml" 1;
    # XSLT Content-Types (can be used for XXE/SSRF)
    "~*application/xslt\+xml" 1;
    "~*text/xsl" 1;
    "~*text/xslt" 1;
    # General XML types (suspicious for non-API endpoints)
    # Note: application/xml is common, only block with entity patterns
}

# XSS via Content-Type - Only block SVG uploads (can contain JavaScript)
map $content_type $bad_ct_xss {
    default 0;
    # SVG can contain JavaScript - block only in POST requests
    "~*image/svg\+xml" 1;
}

# Charset and Encoding Attacks - Block dangerous charsets
map $content_type $bad_ct_charset {
    default 0;
    # UTF-7 allows XSS bypasses
    "~*charset\s*=\s*['\"]?utf-7" 1;
    # UTF-32 encoding attacks
    "~*charset\s*=\s*['\"]?utf-32" 1;
    # ISO-2022-JP allows encoding tricks
    "~*charset\s*=\s*['\"]?iso-2022" 1;
}

# MIME Type Confusion - Block PHP execution types only
map $content_type $bad_ct_mime {
    default 0;
    # PHP execution types (should never be sent as Content-Type)
    "~*application/x-httpd-php" 1;
    "~*text/x-php" 1;
    "~*application/x-php" 1;
    # SSI types
    "~*text/x-server-parsed-html" 1;
}

# MIME Type - Multipart without boundary (malformed) - DISABLED
# This was causing issues with some browsers
map $content_type $bad_ct_multipart {
    default 0;
    # "~*^multipart/(?!.*boundary=)" 1;
}

# Content-Type Payload Injection - Only clear injection patterns
map $content_type $bad_ct_payload {
    default 0;
    # CRLF injection in Content-Type
    "~*(%0d|%0a|%0D|%0A)" 1;
    # SQL Injection patterns (actual SQL keywords, not charset=)
    "~*\b(UNION\s+SELECT|DROP\s+TABLE|INSERT\s+INTO)\b" 1;
    # Null byte
    "~*(%00|\x00)" 1;
}

# Content-Type Overflow (max 256 chars is reasonable)
map $content_type $bad_ct_overflow {
    default 0;
    "~*^.{256,}$" 1;
}

# Combined Content-Type check
map "$bad_ct_xxe$bad_ct_xss$bad_ct_charset$bad_ct_mime$bad_ct_multipart$bad_ct_payload$bad_ct_overflow" $bad_content_type {
    default 0;
    "~*1" 1;
}

# ============================================================================
# XSLT/XXE ATTACK PROTECTION
# ============================================================================

# XSLT via Accept Header - Accept header requesting XSLT processing
map $http_accept $bad_xslt_accept {
    default 0;
    # Accept header requesting XSLT content
    "~*application/xslt\+xml" 1;
    "~*text/xsl" 1;
    "~*text/xslt" 1;
    # XPath content type (potential injection)
    "~*application/xpath\+xml" 1;
}

# X-XSLT and related custom headers (XSLT injection attempts)
map $http_x_xslt $bad_xslt_header {
    default 0;
    # Any X-XSLT header is suspicious
    "~*.+" 1;
}

# X-XSLT-Stylesheet header
map $http_x_xslt_stylesheet $bad_xslt_stylesheet {
    default 0;
    "~*.+" 1;
}

# X-Stylesheet header
map $http_x_stylesheet $bad_xslt_xstylesheet {
    default 0;
    "~*.+" 1;
}

# LibXML External Entity patterns in request body/URI
# These patterns detect XXE injection attempts
map $request_uri $bad_xxe_uri {
    default 0;
    # DOCTYPE with ENTITY declaration (external entity)
    "~*<!DOCTYPE[^>]*\[" 1;
    "~*%3C!DOCTYPE" 1;
    # ENTITY declaration
    "~*<!ENTITY" 1;
    "~*%3C!ENTITY" 1;
    # SYSTEM or PUBLIC entity references
    "~*SYSTEM\s*['\"]" 1;
    "~*PUBLIC\s*['\"]" 1;
    # Parameter entity references (%entity;)
    "~*%[a-zA-Z_][a-zA-Z0-9_]*;" 1;
    # PHP protocol in XML (php://input, php://filter)
    "~*php://" 1;
    # File protocol
    "~*file://" 1;
    # Expect protocol (PHP wrapper for command execution)
    "~*expect://" 1;
    # Data protocol with base64 (can embed malicious content)
    "~*data:[^,]*base64" 1;
}

# LibXML patterns in query string
map $query_string $bad_xxe_query {
    default 0;
    # Entity declarations
    "~*<!ENTITY" 1;
    "~*%3C!ENTITY" 1;
    # DOCTYPE declarations
    "~*<!DOCTYPE" 1;
    "~*%3C!DOCTYPE" 1;
    # XML external references
    "~*SYSTEM\s*['\"]" 1;
    "~*PUBLIC\s*['\"]" 1;
    # XInclude namespace (another XXE vector)
    "~*xmlns:xi=" 1;
    "~*xi:include" 1;
    # XSLT include/import
    "~*xsl:include" 1;
    "~*xsl:import" 1;
}

# XSLT specific patterns in URI
map $request_uri $bad_xslt_uri {
    default 0;
    # XSLT tags
    "~*<xsl:" 1;
    "~*%3Cxsl:" 1;
    # XSLT document() function (SSRF)
    "~*document\s*\(" 1;
    # XSLT unparsed-entity-uri (external access)
    "~*unparsed-entity-uri" 1;
}

# Combined XSLT/XXE check
map "$bad_xslt_accept$bad_xslt_header$bad_xslt_stylesheet$bad_xslt_xstylesheet$bad_xxe_uri$bad_xxe_query$bad_xslt_uri" $bad_xslt_xxe {
    default 0;
    "~*1" 1;
}

# ============================================================================
# WAF BYPASS PROTECTION
# ============================================================================

# Double URL Encoding (encoding bypass) - %25XX patterns
map $request_uri $bad_waf_double_encode {
    default 0;
    # Double encoded characters (%25 = encoded %)
    "~*%25[0-9a-fA-F]{2}" 1;
    # Common double encoded attacks
    "~*%252e%252e" 1;  # Double encoded ../
    "~*%252f" 1;       # Double encoded /
    "~*%255c" 1;       # Double encoded \
    "~*%2527" 1;       # Double encoded '
    "~*%2522" 1;       # Double encoded "
    "~*%253c" 1;       # Double encoded <
    "~*%253e" 1;       # Double encoded >
}

# Triple URL Encoding - %2525XX patterns
map $request_uri $bad_waf_triple_encode {
    default 0;
    # Triple encoded % (%2525)
    "~*%2525" 1;
    # Any %25%25 pattern
    "~*%25%25" 1;
}

# Unicode Encoding Bypass - \uXXXX and %uXXXX patterns
map $request_uri $bad_waf_unicode {
    default 0;
    # IIS Unicode encoding (%uXXXX)
    "~*%u[0-9a-fA-F]{4}" 1;
    # JS Unicode escape (\uXXXX)
    "~*\\\\u[0-9a-fA-F]{4}" 1;
    # UTF-8 overlong encoding (C0, C1 prefix)
    "~*%c0%[89a-f]" 1;
    "~*%c1%[89a-f]" 1;
    # Fullwidth characters (U+FF00-U+FFEF)
    "~*%ef%bc" 1;
    "~*%ef%bd" 1;
}

# Query string encoding bypass
map $query_string $bad_waf_query_encode {
    default 0;
    # Double encoding in query
    "~*%25[0-9a-fA-F]{2}" 1;
    # Unicode encoding in query
    "~*%u[0-9a-fA-F]{4}" 1;
    # Triple encoding
    "~*%2525" 1;
}

# HTTP Method Override headers (WAF bypass via method tampering)
map $http_x_http_method_override $bad_waf_method_override1 {
    default 0;
    # Block any method override attempt
    "~*.+" 1;
}

map $http_x_method_override $bad_waf_method_override2 {
    default 0;
    "~*.+" 1;
}

map $http_x_http_method $bad_waf_method_override3 {
    default 0;
    "~*.+" 1;
}

# X-Original-Method (another variant)
map $http_x_original_method $bad_waf_method_override4 {
    default 0;
    "~*.+" 1;
}

# Combined method override check
map "$bad_waf_method_override1$bad_waf_method_override2$bad_waf_method_override3$bad_waf_method_override4" $bad_waf_method_override {
    default 0;
    "~*1" 1;
}

# HTTP/0.9 Protocol Bypass
# HTTP/0.9 doesn't have headers, used for bypass and fingerprinting
map $server_protocol $bad_waf_protocol {
    default 0;
    # Block HTTP/0.9 requests
    "HTTP/0.9" 1;
    # Also catch empty protocol (malformed)
    "" 1;
}

# Size-based bypass - Very large Content-Length (potential DoS or bypass)
map $content_length $bad_waf_large_body {
    default 0;
    # Body larger than 10MB (10485760 bytes) - adjust as needed
    "~*^[1-9][0-9]{7,}$" 1;
    # Body larger than 100MB
    "~*^[1-9][0-9]{8,}$" 1;
}

# Transfer-Encoding obfuscation (already in smuggling but add specifics)
map $http_transfer_encoding $bad_waf_te_obfuscation {
    default 0;
    # TE with inline comments (HTTP smuggling variant)
    "~*chunked\\s*/\\*" 1;
    "~*\\*/\\s*chunked" 1;
    # TE with hex encoding
    "~*%63%68%75%6e%6b%65%64" 1;
    # TE with mixed case and spaces
    "~*\\s+chunked\\s+" 1;
    # TE with null bytes
    "~*chunked%00" 1;
    "~*%00chunked" 1;
}

# Combined WAF Bypass check
map "$bad_waf_double_encode$bad_waf_triple_encode$bad_waf_unicode$bad_waf_query_encode$bad_waf_method_override$bad_waf_protocol$bad_waf_large_body$bad_waf_te_obfuscation" $bad_waf_bypass {
    default 0;
    "~*1" 1;
}

# ============================================================================
# ACCEPT-ENCODING ATTACKS PROTECTION
# ============================================================================

# Encoding Manipulation - Too many encodings or suspicious patterns
map $http_accept_encoding $bad_ae_manipulation {
    default 0;
    # Too many commas (more than 10 encodings is suspicious)
    "~*(,.*){10,}" 1;
    # Repeated encoding patterns (DoS attempt)
    "~*(gzip.*){5,}" 1;
    "~*(deflate.*){5,}" 1;
    "~*(br.*){5,}" 1;
    # Chunked in Accept-Encoding (HTTP smuggling attempt)
    "~*\bchunked\b" 1;
    # Transfer-Encoding keywords in Accept-Encoding
    "~*\btransfer-encoding\b" 1;
    "~*\bte\b" 1;
}

# Payload Injection in Accept-Encoding - Only clear attack patterns
map $http_accept_encoding $bad_ae_payload {
    default 0;
    # XSS patterns
    "~*(<|%3C).*script.*(>|%3E)" 1;
    "~*(javascript|vbscript):" 1;
    # Path traversal
    "~*(\.\.\/|\.\.\\\\|%2e%2e%2f)" 1;
    # Command injection with shell commands
    "~*(\||&&)\s*(cat|ls|id|whoami|wget|curl|nc|bash|sh)\b" 1;
    # Null byte
    "~*(%00|\x00)" 1;
}

# CRLF and Malformed Accept-Encoding
map $http_accept_encoding $bad_ae_malformed {
    default 0;
    # CRLF injection
    "~*(%0d|%0a|%0D|%0A)" 1;
    # Malformed q-value (should be 0-1)
    "~*;q=([2-9]|[0-9]{2,})" 1;
    # Negative q-value
    "~*;q=-" 1;
}

# Accept-Encoding Overflow (max 512 chars is reasonable)
map $http_accept_encoding $bad_ae_overflow {
    default 0;
    "~*^.{512,}$" 1;
}

# Too many wildcards (DoS/bypass attempt) - DISABLED (was too aggressive)
map $http_accept_encoding $bad_ae_wildcards {
    default 0;
    # "~*(\*.*){3,}" 1;
}

# Combined Accept-Encoding check
map "$bad_ae_manipulation$bad_ae_payload$bad_ae_malformed$bad_ae_overflow$bad_ae_wildcards" $bad_accept_encoding {
    default 0;
    "~*1" 1;
}

# ============================================================================
# X-FORWARDED-FOR SPOOFING PROTECTION
# ============================================================================

# X-Forwarded-For - Private/Local IPs (SSRF protection)
map $http_x_forwarded_for $bad_xff_private {
    default 0;
    # Loopback
    "~*\b127\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\blocalhost\b" 1;
    # Private ranges
    "~*\b192\.168\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b10\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b172\.(1[6-9]|2[0-9]|3[0-1])\.\d{1,3}\.\d{1,3}\b" 1;
    # IPv6 loopback
    "~*::1\b" 1;
    # Zero address
    "~*\b0\.0\.0\.0\b" 1;
}

# X-Forwarded-For - Cloud Metadata IPs (SSRF protection)
map $http_x_forwarded_for $bad_xff_metadata {
    default 0;
    # AWS metadata
    "~*\b169\.254\.169\.254\b" 1;
    # AWS ECS metadata
    "~*\b169\.254\.170\.2\b" 1;
    # Link-local range
    "~*\b169\.254\.\d{1,3}\.\d{1,3}\b" 1;
    # Alibaba Cloud metadata
    "~*\b100\.100\.100\.200\b" 1;
    # Google Cloud metadata
    "~*metadata\.google\.internal" 1;
}

# X-Forwarded-For - Payload Injection
map $http_x_forwarded_for $bad_xff_payload {
    default 0;
    # SQL Injection
    "~*('|\")\s*(OR|AND|UNION|SELECT)\b" 1;
    "~*\b(UNION\s+SELECT|DROP\s+TABLE)\b" 1;
    # XSS
    "~*(<|%3C).*script.*(>|%3E)" 1;
    "~*(javascript|vbscript):" 1;
    # Command injection
    "~*(;|\||&&)\s*(cat|ls|id|whoami|wget|curl|bash|sh)\b" 1;
    # CRLF injection
    "~*(%0d|%0a|%0D|%0A)" 1;
}

# X-Real-IP spoofing (alternative header)
map $http_x_real_ip $bad_xrealip {
    default 0;
    "~*\b127\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\blocalhost\b" 1;
    "~*\b192\.168\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b10\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b169\.254\.\d{1,3}\.\d{1,3}\b" 1;
}

# X-Client-IP spoofing (alternative header)
map $http_x_client_ip $bad_xclientip {
    default 0;
    "~*\b127\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\blocalhost\b" 1;
    "~*\b192\.168\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b10\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b169\.254\.\d{1,3}\.\d{1,3}\b" 1;
}

# X-Originating-IP spoofing (alternative header)
map $http_x_originating_ip $bad_xoriginatingip {
    default 0;
    "~*\b127\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\blocalhost\b" 1;
    "~*\b10\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b169\.254\.\d{1,3}\.\d{1,3}\b" 1;
}

# X-Remote-IP spoofing (alternative header)
map $http_x_remote_ip $bad_xremoteip {
    default 0;
    "~*\b127\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\blocalhost\b" 1;
    "~*\b192\.168\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b10\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
}

# X-Remote-Addr spoofing (alternative header)
map $http_x_remote_addr $bad_xremoteaddr {
    default 0;
    "~*\b127\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\blocalhost\b" 1;
    "~*\b192\.168\.\d{1,3}\.\d{1,3}\b" 1;
    "~*\b10\.\d{1,3}\.\d{1,3}\.\d{1,3}\b" 1;
}

# Combined X-Forwarded-For check
map "$bad_xff_private$bad_xff_metadata$bad_xff_payload" $bad_xff_main {
    default 0;
    "~*1" 1;
}

# Combined alternative headers check
map "$bad_xrealip$bad_xclientip$bad_xoriginatingip$bad_xremoteip$bad_xremoteaddr" $bad_xff_alt {
    default 0;
    "~*1" 1;
}

# Final XFF check
map "$bad_xff_main$bad_xff_alt" $bad_xff {
    default 0;
    "~*1" 1;
}

# ============================================================================
# RANGE HEADER ATTACKS PROTECTION
# ============================================================================

# Range DoS - Too many ranges (more than 5 is suspicious)
map $http_range $bad_range_dos {
    default 0;
    # Multiple ranges (DoS via multipart response generation)
    "~*(,.*){5,}" 1;
    # Overlapping ranges pattern
    "~*bytes=\d+-\d+,\s*\d+-\d+,\s*\d+-\d+,\s*\d+-\d+" 1;
}

# Range Malformed - Invalid format
map $http_range $bad_range_malformed {
    default 0;
    # Suffix range without proper format
    "~*bytes=\s*-\s*$" 1;
    # Negative values
    "~*bytes=\s*-\d+-" 1;
    # Inverted range (start > end) - can't detect perfectly but catch obvious
    "~*bytes=\d{10,}-\d{1,3}\b" 1;
    # No number after bytes=
    "~*bytes=\s*[^0-9-]" 1;
    # Invalid separators
    "~*bytes=\d+;\d+" 1;
    "~*bytes=\d+\|\d+" 1;
}

# Range Payload Injection
map $http_range $bad_range_payload {
    default 0;
    # XSS
    "~*(<|%3C).*script.*(>|%3E)" 1;
    "~*(javascript|vbscript):" 1;
    # SQL Injection
    "~*('|\")\s*(OR|AND|UNION|SELECT)\b" 1;
    "~*\b(UNION\s+SELECT|DROP\s+TABLE)\b" 1;
    # Command injection
    "~*(;|\||&&)\s*(cat|ls|id|whoami|wget|curl|bash|sh)\b" 1;
    "~*(\$\(|`)" 1;
    # Path traversal
    "~*(\.\.\/|\.\.\\\\|%2e%2e%2f)" 1;
    # Null byte
    "~*(%00|\x00)" 1;
    # CRLF
    "~*(%0d|%0a|%0D|%0A)" 1;
}

# Range Overflow - Extreme values
map $http_range $bad_range_overflow {
    default 0;
    # Very large numbers (potential integer overflow)
    "~*bytes=\d{15,}" 1;
    # INT_MAX and beyond patterns
    "~*bytes=(214748364[8-9]|21474836[5-9]\d|2147483[7-9]\d{2}|214748[4-9]\d{3}|21474[9]\d{4}|2147[5-9]\d{5}|214[8-9]\d{6}|21[5-9]\d{7}|2[2-9]\d{8}|[3-9]\d{9}|\d{11,})" 1;
    # Header too long (more than 256 chars is suspicious for Range)
    "~*^.{256,}$" 1;
}

# Range Invalid Unit
map $http_range $bad_range_unit {
    default 0;
    # Only "bytes" is standard, others are suspicious
    "~*^(?!bytes)[a-z]+" 1;
    # Typos or obfuscation attempts
    "~*^(bytess|byte|bites|Bytes|BYTES)" 1;
}

# Combined Range check
map "$bad_range_dos$bad_range_malformed$bad_range_payload$bad_range_overflow$bad_range_unit" $bad_range {
    default 0;
    "~*1" 1;
}

# ============================================================================
# HTTP RESPONSE SMUGGLING / DESYNC PROTECTION
# ============================================================================

# Transfer-Encoding Obfuscation - Suspicious TE patterns
map $http_transfer_encoding $bad_te_obfuscation {
    default 0;
    # TE with leading/trailing whitespace
    "~*^\s+chunked" 1;
    "~*chunked\s+$" 1;
    # TE with tabs (HTTP desync)
    "~*\t" 1;
    # TE with identity (used for smuggling)
    "~*identity" 1;
    # TE with newline/CRLF
    "~*(%0d|%0a|%0D|%0A|\r|\n)" 1;
    # Multiple TEs in same header
    "~*chunked.*chunked" 1;
    # Case variations (TE capitalized - desync attempts)
    "~*^(CHUNKED|Chunked|cHuNkEd|ChUnKeD|TRANSFER-ENCODING)$" 1;
    # Chunked with extra characters
    "~*chunked[^,\s]" 1;
    # TE with null byte (bypass attempts)
    "~*(%00|\x00)" 1;
    # TE with comma (multiple values - TE.TE desync)
    "~*," 1;
}

# X-Transfer-Encoding (non-standard, used for smuggling)
map $http_x_transfer_encoding $bad_xte {
    default 0;
    "~*.+" 1;
}

# Transfer_Encoding (underscore variant, used for smuggling)
map $http_transfer_encoding_ $bad_te_underscore {
    default 0;
    "~*.+" 1;
}

# TE header (short form, can be used for smuggling)
map $http_te $bad_te_short {
    default 0;
    # TE with chunked (suspicious in combination with Transfer-Encoding)
    "~*chunked" 1;
    # TE with trailers and chunked
    "~*trailers.*chunked|chunked.*trailers" 1;
}

# Content-Length and Transfer-Encoding conflict detection
# Note: This requires both headers present - detected via combined check
map $http_transfer_encoding $te_present {
    default 0;
    "~*.+" 1;
}

map $content_length $cl_present {
    default 0;
    "~*.+" 1;
}

# CL.TE / TE.CL detection - presence of both headers is suspicious
map "$te_present$cl_present" $bad_cl_te_conflict {
    default 0;
    "11" 1;
}

# Duplicate Transfer-Encoding detection (via comma)
map $http_transfer_encoding $bad_te_duplicate {
    default 0;
    "~*,.*," 1;
    "~*chunked.*,.*chunked" 1;
}

# ============================================================================
# RESPONSE QUEUE DESYNC PROTECTION (CL.0, TE.0, H2.0)
# ============================================================================

# CL.0 Desync - Content-Length zero with body or suspicious patterns
map $content_length $bad_cl_zero {
    default 0;
    # Content-Length: 0 (suspicious when combined with body - checked at app level)
    # CL with spaces (desync attempt)
    "~*^\s" 1;
    "~*\s$" 1;
    # CL with tabs
    "~*\t" 1;
    # CL negative (invalid)
    "~*^-" 1;
    # CL non-numeric (invalid)
    "~*[^0-9]" 1;
    # CL with CRLF
    "~*(%0d|%0a|%0D|%0A)" 1;
}

# X-Content-Length (non-standard, used for smuggling)
map $http_x_content_length $bad_xcl {
    default 0;
    "~*.+" 1;
}

# Content_Length (underscore variant, used for smuggling)
map $http_content_length_ $bad_cl_underscore {
    default 0;
    "~*.+" 1;
}

# ============================================================================
# CHUNKED ENCODING DESYNC PROTECTION
# ============================================================================

# Chunk size malformed patterns (detected in Transfer-Encoding context)
# Note: Actual chunk validation happens at HTTP layer, these catch header abuse
map $http_transfer_encoding $bad_te_chunk_abuse {
    default 0;
    # Chunk extension patterns in TE header (shouldn't be there)
    "~*chunked\s*;" 1;
    # Invalid chunk modifiers
    "~*chunked\s*\(" 1;
    "~*chunked\s*\[" 1;
    "~*chunked\s*\{" 1;
    # Chunk with encoding params
    "~*chunked\s*q=" 1;
}

# Trailer header abuse - only allowed with chunked encoding and specific headers
map $http_trailer $bad_trailer_abuse {
    default 0;
    # Trailer with forbidden headers (per RFC 7230)
    "~*(transfer-encoding|content-length|host|trailer)" 1;
    # Trailer with authentication headers (security risk)
    "~*(authorization|www-authenticate|proxy-authenticate|proxy-authorization)" 1;
    # Trailer with caching headers (can cause cache poisoning)
    "~*(cache-control|expires|pragma|age)" 1;
    # Trailer with content headers
    "~*(content-type|content-encoding|content-range)" 1;
    # Trailer with control headers
    "~*(set-cookie|cookie)" 1;
    # CRLF injection in Trailer
    "~*(%0d|%0a|%0D|%0A)" 1;
}

# ============================================================================
# PROTOCOL SMUGGLING PROTECTION (HTTP/1.1 in HTTP/2, etc)  
# ============================================================================

# X-HTTP-Version header (version forcing attempt)
map $http_x_http_version $bad_http_version {
    default 0;
    "~*.+" 1;
}

# X-HTTP-Protocol header (protocol forcing)
map $http_x_http_protocol $bad_http_protocol {
    default 0;
    "~*.+" 1;
}

# Via header abuse - suspicious patterns
map $http_via $bad_via_abuse {
    default 0;
    # Via with injection patterns
    "~*(<|>|script|javascript)" 1;
    "~*('|\")(OR|AND|SELECT|DROP)" 1;
    # Via with CRLF
    "~*(%0d|%0a|%0D|%0A)" 1;
    # Via with null byte
    "~*(%00|\x00)" 1;
    # Via with excessive hops (potential amplification)
    "~*(,.*){10,}" 1;
    # Via trying to spoof internal servers
    "~*(localhost|127\.0\.0\.1|192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.)" 1;
    # Via with HTTP/2 downgrade attempt
    "~*HTTP/2.*HTTP/1" 1;
}

# ============================================================================
# SLOW HEADERS / TIMEOUT DESYNC PROTECTION
# ============================================================================

# These are primarily handled by nginx config directives but we can detect
# suspicious patterns in headers that might indicate slow header attacks

# Expect header with invalid values (100-continue attacks)
map $http_expect $bad_expect_abuse {
    default 0;
    # Anything other than 100-continue
    "~*^(?!100-continue$).+" 1;
}

# Connection header with timeout manipulation
map $http_connection $bad_connection_timeout {
    default 0;
    # Very long keep-alive values
    "~*keep-alive.*timeout\s*=\s*\d{4,}" 1;
    # Multiple connection directives (desync)
    "~*(,.*){5,}" 1;
}

# ============================================================================
# HTTP/2 SPECIFIC PROTECTIONS
# ============================================================================

# X-HTTP2-Scheme (h2 smuggling)
map $http_x_http2_scheme $bad_h2_scheme {
    default 0;
    "~*.+" 1;
}

# X-HTTP2-Stream-Id (h2 stream manipulation)
map $http_x_http2_stream_id $bad_h2_stream {
    default 0;
    "~*.+" 1;
}

# X-H2-Pushed (h2 push abuse)
map $http_x_h2_pushed $bad_h2_pushed {
    default 0;
    "~*.+" 1;
}

# ============================================================================
# ADDITIONAL ENCODING DESYNC PATTERNS
# ============================================================================

# Transfer-Encoding with various obfuscation techniques
map $http_transfer_encoding $bad_te_encoding {
    default 0;
    # UTF-8 encoded "chunked"
    "~*%63%68%75%6e%6b%65%64" 1;
    # Double encoding
    "~*%25" 1;
    # Unicode encoding
    "~*\\\\u006" 1;
    # Quoted chunked
    "~*\"chunked\"" 1;
    "~*'chunked'" 1;
}

# Content-Length obfuscation
map $content_length $bad_cl_encoding {
    default 0;
    # Hexadecimal CL values
    "~*0x" 1;
    # Scientific notation
    "~*e\\+" 1;
    "~*E\\+" 1;
    # Multiple CL values (comma-separated)
    "~*," 1;
}

# ============================================================================
# COMBINED HTTP SMUGGLING/DESYNC CHECKS
# ============================================================================

# Combined Response Queue Desync check
map "$bad_cl_zero$bad_xcl$bad_cl_underscore" $bad_cl_desync {
    default 0;
    "~*1" 1;
}

# Combined Chunked Desync check  
map "$bad_te_chunk_abuse$bad_trailer_abuse" $bad_chunk_desync {
    default 0;
    "~*1" 1;
}

# Combined Protocol Smuggling check
map "$bad_http_version$bad_http_protocol$bad_via_abuse" $bad_protocol_smuggling {
    default 0;
    "~*1" 1;
}

# Combined H2 Desync check
map "$bad_h2_scheme$bad_h2_stream$bad_h2_pushed" $bad_h2_desync {
    default 0;
    "~*1" 1;
}

# Combined Encoding Desync check
map "$bad_te_encoding$bad_cl_encoding" $bad_encoding_desync {
    default 0;
    "~*1" 1;
}

# Combined Timeout Desync check
map "$bad_expect_abuse$bad_connection_timeout" $bad_timeout_desync {
    default 0;
    "~*1" 1;
}

# Final HTTP Smuggling check (all categories)
map "$bad_te_obfuscation$bad_xte$bad_te_underscore$bad_te_short$bad_cl_te_conflict$bad_te_duplicate$bad_cl_desync$bad_chunk_desync$bad_protocol_smuggling$bad_h2_desync$bad_encoding_desync$bad_timeout_desync" $bad_smuggling {
    default 0;
    "~*1" 1;
}

# ============================================================================
# PROTOCOL DOWNGRADE PROTECTION
# ============================================================================

# Upgrade header - Block suspicious upgrade requests
map $http_upgrade $bad_upgrade {
    default 0;
    # Block downgrade to HTTP/1.0 or HTTP/1.1
    "~*http/1\.[01]" 1;
    # Block h2c (HTTP/2 cleartext) upgrade attempts
    "~*h2c" 1;
    # Block websocket upgrades with suspicious patterns
    "~*(http|https)://" 1;
}

# Connection header - Block upgrade connection requests (unless WebSocket)
# Note: WebSocket upgrade is legitimate, but Connection: Upgrade alone is suspicious
map $http_connection $bad_connection_upgrade {
    default 0;
    # Connection: Upgrade without proper Upgrade header
    "~*^upgrade$" 1;
}

# Combined with Upgrade header check - block if Connection: Upgrade but no valid Upgrade
map "$http_connection:$http_upgrade" $bad_protocol_downgrade {
    default 0;
    # Connection: Upgrade with HTTP downgrade
    "~*upgrade.*:.*http/1" 1;
    # Connection: Upgrade with h2c
    "~*upgrade.*:.*h2c" 1;
    # Connection: Upgrade without websocket
    "~*^upgrade:$" 1;
}

# Combined Protocol Downgrade check
map "$bad_upgrade$bad_connection_upgrade$bad_protocol_downgrade" $bad_downgrade {
    default 0;
    "~*1" 1;
}

# ============================================================================
# H2C SMUGGLING PROTECTION
# H2C allows upgrade from HTTP/1.1 to HTTP/2 without TLS
# Can be used for proxy bypass and access to internal endpoints
# ============================================================================

# HTTP2-Settings header (used for h2c upgrade, should not be sent by clients)
map $http_http2_settings $bad_h2c_settings {
    default 0;
    # Any HTTP2-Settings header is suspicious (used for h2c attacks)
    "~*.+" 1;
}

# Alternative HTTP2-Settings header formats
map $http_http2_settings_ $bad_h2c_settings_underscore {
    default 0;
    "~*.+" 1;
}

# X-HTTP2-Settings variant
map $http_x_http2_settings $bad_h2c_xsettings {
    default 0;
    "~*.+" 1;
}

# Connection header with HTTP2-Settings (h2c upgrade indicator)
map $http_connection $bad_h2c_connection {
    default 0;
    # Connection header mentioning HTTP2-Settings (h2c smuggling)
    "~*http2-settings" 1;
    # Connection: Upgrade, HTTP2-Settings pattern
    "~*upgrade.*http2" 1;
}

# Upgrade header specifically for h2c patterns
map $http_upgrade $bad_h2c_upgrade {
    default 0;
    # Direct h2c upgrade
    "~*^h2c$" 1;
    "~*^h2c,?" 1;
    "~*,?h2c$" 1;
    # h2 (HTTP/2 over cleartext)
    "~*^h2$" 1;
    # Prior knowledge pattern
    "~*PRI" 1;
}

# Combined H2C headers check
map "$http_connection:$http_upgrade" $bad_h2c_combo {
    default 0;
    # Connection: Upgrade with Upgrade: h2c
    "~*upgrade.*:.*h2c" 1;
    # Connection: HTTP2-Settings with any upgrade
    "~*http2-settings.*:.*" 1;
    # HTTP/2 upgrade patterns
    "~*upgrade.*:.*h2" 1;
}

# PRI method detection (HTTP/2 prior knowledge)
# Note: This requires checking in the request line, do it in $request_method
map $request_method $bad_h2c_pri {
    default 0;
    # PRI is the HTTP/2 connection preface
    "PRI" 1;
}

# Internal endpoints that should be blocked (common internal paths)
map $request_uri $bad_internal_endpoint {
    default 0;
    # Common internal endpoints
    "~*^/internal(/|$)" 1;
    "~*^/metrics(/|$)" 1;
    "~*^/health(/|$)" 1;
    "~*^/healthz(/|$)" 1;
    "~*^/ready(/|$)" 1;
    "~*^/readiness(/|$)" 1;
    "~*^/liveness(/|$)" 1;
    "~*^/debug(/|$)" 1;
    "~*^/actuator(/|$)" 1;
    "~*^/prometheus(/|$)" 1;
    "~*^/grafana(/|$)" 1;
    # Kubernetes/Docker internal paths
    "~*^/apis(/|$)" 1;
    "~*^/api/v1/nodes" 1;
    "~*^/api/v1/pods" 1;
    "~*^/api/v1/services" 1;
}

# Combined H2C Smuggling check
map "$bad_h2c_settings$bad_h2c_settings_underscore$bad_h2c_xsettings$bad_h2c_connection$bad_h2c_upgrade$bad_h2c_combo$bad_h2c_pri$bad_internal_endpoint" $bad_h2c_smuggling {
    default 0;
    "~*1" 1;
}

# ============================================================================
# HOP-BY-HOP HEADERS ABUSE PROTECTION
# ============================================================================

# Connection header abuse - trying to strip important headers
map $http_connection $bad_hbh_connection {
    default 0;
    # Trying to remove security headers via Connection
    "~*(authorization|cookie|x-csrf|x-xsrf)" 1;
    # Trying to manipulate content headers
    "~*(content-length|content-type|transfer-encoding)" 1;
    # Multiple headers in Connection (abuse attempt)
    "~*(,.*){3,}" 1;
    # Trying to remove forwarding headers
    "~*(x-forwarded-host|x-forwarded-proto|x-forwarded-for)" 1;
}

# Proxy headers that shouldn't be sent by clients
map $http_proxy_connection $bad_hbh_proxy_conn {
    default 0;
    "~*.+" 1;
}

map $http_proxy_authenticate $bad_hbh_proxy_auth {
    default 0;
    "~*.+" 1;
}

map $http_proxy_authorization $bad_hbh_proxy_authz {
    default 0;
    "~*.+" 1;
}

# X-Proxy-Connection (non-standard, suspicious)
map $http_x_proxy_connection $bad_hbh_xproxy {
    default 0;
    "~*.+" 1;
}

# Multiple Connection headers (duplicated)
map $http_connection $bad_hbh_multi_conn {
    default 0;
    # Duplicated connection values
    "~*(close.*close|keep-alive.*keep-alive|upgrade.*upgrade)" 1;
}

# Trailer header abuse - now covered by $bad_trailer_abuse in smuggling section
# Reference $bad_trailer_abuse for comprehensive trailer protection

# Max-Forwards manipulation
map $http_max_forwards $bad_hbh_maxforwards {
    default 0;
    # Negative values
    "~*^-" 1;
    # Non-numeric (except for legitimate values)
    "~*[^0-9]" 1;
}

# Via header manipulation - now covered by $bad_via_abuse in smuggling section
# Reference $bad_via_abuse for comprehensive Via header protection

# Forwarded header with suspicious patterns
map $http_forwarded $bad_hbh_forwarded {
    default 0;
    # Injection attempts
    "~*(<|>|script|javascript)" 1;
    "~*('|\")(OR|AND|SELECT)" 1;
    # Localhost/internal bypass
    "~*for=(127\.|192\.168\.|10\.|localhost)" 1;
}

# Combined Hop-by-Hop check (trailer and via now in smuggling section)
map "$bad_hbh_connection$bad_hbh_proxy_conn$bad_hbh_proxy_auth$bad_hbh_proxy_authz$bad_hbh_xproxy$bad_hbh_multi_conn$bad_hbh_maxforwards$bad_hbh_forwarded$bad_trailer_abuse$bad_via_abuse" $bad_hopbyhop {
    default 0;
    "~*1" 1;
}

# ============================================================================
# CACHE POISONING / CACHE DECEPTION PROTECTION
# ============================================================================

# Cache Key Manipulation - X-Host and X-Forwarded-Server
map $http_x_host $bad_cache_xhost {
    default 0;
    "~*.+" 1;
}

map $http_x_forwarded_server $bad_cache_xfwdserver {
    default 0;
    "~*.+" 1;
}

map $http_x_forwarded_scheme $bad_cache_xfwdscheme {
    default 0;
    "~*.+" 1;
}

# Unkeyed Headers Abuse
map $http_x_forwarded_port $bad_cache_xfwdport {
    default 0;
    "~*.+" 1;
}

map $http_x_forwarded_ssl $bad_cache_xfwdssl {
    default 0;
    "~*.+" 1;
}

map $http_x_url_scheme $bad_cache_xurlscheme {
    default 0;
    "~*.+" 1;
}

map $http_x_custom_ip_auth $bad_cache_xcustomip {
    default 0;
    "~*.+" 1;
}

# Fat GET Requests - GET with body is suspicious
# Check if GET request has Content-Type (unusual)
map "$request_method:$content_type" $bad_cache_fatget {
    default 0;
    # GET with Content-Type is suspicious
    "~*^GET:.+" 1;
}

# Cache Control Manipulation
map $http_if_modified_since $bad_cache_ifmodified {
    default 0;
    # Date far in the future (year 2100+)
    "~*21[0-9]{2}" 1;
    "~*22[0-9]{2}" 1;
    # Malformed dates
    "~*(<|>|script|javascript)" 1;
    "~*('|\")(OR|AND|SELECT)" 1;
}

map $http_if_none_match $bad_cache_ifnonematch {
    default 0;
    # Injection attempts in ETag
    "~*(<|>|script|javascript)" 1;
    "~*('|\")(OR|AND|SELECT)" 1;
    "~*(%0d|%0a|%0D|%0A)" 1;
}

# Header injection attempts
map $http_x_injected_header $bad_cache_injected {
    default 0;
    "~*.+" 1;
}

# Combined Cache Poisoning check
map "$bad_cache_xhost$bad_cache_xfwdserver$bad_cache_xfwdscheme$bad_cache_xfwdport$bad_cache_xfwdssl$bad_cache_xurlscheme$bad_cache_xcustomip$bad_cache_fatget$bad_cache_ifmodified$bad_cache_ifnonematch$bad_cache_injected" $bad_cache {
    default 0;
    "~*1" 1;
}

# ============================================================================
# HTTP CONNECTION CONTAMINATION PROTECTION
# ============================================================================

# Backend Connection Abuse - Headers that shouldn't come from clients
map $http_x_backend_server $bad_contam_backend {
    default 0;
    "~*.+" 1;
}

map $http_x_real_destination $bad_contam_realdest {
    default 0;
    "~*.+" 1;
}

map $http_x_upstream_host $bad_contam_upstream {
    default 0;
    "~*.+" 1;
}

# Keep-Alive manipulation
map $http_keep_alive $bad_contam_keepalive {
    default 0;
    # Keep-Alive with suspicious patterns
    "~*(<|>|script|javascript)" 1;
    "~*('|\")(OR|AND|SELECT)" 1;
    # Extremely long timeout (potential DoS)
    "~*timeout=\d{5,}" 1;
    # Max with suspicious values
    "~*max=\d{5,}" 1;
}

# Expect header abuse - now covered by $bad_expect_abuse in smuggling section
# Reference $bad_expect_abuse for comprehensive Expect header protection

# WebSocket upgrade abuse (partial/malformed)
map "$http_upgrade:$http_connection" $bad_contam_websocket {
    default 0;
    # WebSocket upgrade without proper connection header
    "~*websocket:(?!.*upgrade)" 1;
    # Partial websocket string (obfuscation)
    "~*websock:.*" 1;
    "~*socket:.*" 1;
}

# HTTP/2 upgrade abuse (h2c cleartext)
map $http_upgrade $bad_contam_h2upgrade {
    default 0;
    # h2c upgrade attempts
    "~*h2c" 1;
    # HTTP/2 over cleartext
    "~*h2" 1;
}

# Accept-Charset exotic values (potential bypass)
map $http_accept_charset $bad_contam_charset {
    default 0;
    # Very unusual charsets that might cause issues
    "~*(utf-32|utf-7|iso-2022)" 1;
    # Injection attempts
    "~*(<|>|script|javascript)" 1;
    "~*('|\")(OR|AND|SELECT)" 1;
}

# Transfer-Encoding: identity (used for smuggling)
# Note: identity is already handled in smuggling section
# Additional check for combinations
map $http_transfer_encoding $bad_contam_te_identity {
    default 0;
    "~*identity" 1;
}

# Combined Connection Contamination check (expect now in smuggling section)
map "$bad_contam_backend$bad_contam_realdest$bad_contam_upstream$bad_contam_keepalive$bad_contam_websocket$bad_contam_h2upgrade$bad_contam_charset$bad_contam_te_identity$bad_expect_abuse" $bad_contamination {
    default 0;
    "~*1" 1;
}

# ============================================================================
# PATH/URL BYPASS PROTECTION
# ============================================================================



# Unicode Tricks - Overlong UTF-8 and Fullwidth characters
map $request_uri $bad_path_unicode {
    default 0;
    # Overlong UTF-8 slash (%c0%af)
    "~*%c0%af" 1;
    # Overlong UTF-8 dot (%c0%ae)
    "~*%c0%ae" 1;
    # Fullwidth slash ( = %ef%bc%8f)
    "~*%ef%bc%8f" 1;
    # Fullwidth dot (= %ef%bc%8e or  = %ef%bd%a1)
    "~*%ef%bc%8e" 1;
    "~*%ef%bd%a1" 1;
    # Overlong UTF-8 sequences (C0, C1 are always overlong)
    "~*%c0[%0-9a-f]{2}" 1;
    "~*%c1[%0-9a-f]{2}" 1;
}

# Encoded Space/Tab in sensitive paths
map $request_uri $bad_path_whitespace {
    default 0;
    # Encoded space before path separator
    "~*%20/" 1;
    # Encoded space at end of admin paths
    "~*(admin|config|install|upgrade|setup)%20" 1;
    # Encoded tab
    "~*%09" 1;
    # Multiple encoded spaces
    "~*(%20.*){3,}" 1;
}

# Path Normalization Bypass - Dot patterns
map $request_uri $bad_path_dots {
    default 0;
    # Trailing dot (admin.)
    "~*/[a-zA-Z0-9_-]+\.$" 1;
    # Double dot-dot pattern used for bypass
    "~*/\.\./" 1;
    # Dot-slash-dot patterns
    "~*/\.\./\.\." 1;
}

# Encoded characters in sensitive admin paths
map $request_uri $bad_path_encoded {
    default 0;
    # Encoded slash followed by admin keywords
    "~*%2f(admin|wp-admin|phpmyadmin|config|install)" 1;
    # Admin keywords with encoded characters
    "~*(admin|wp-admin)%2[ef0]" 1;
}

# Combined Path Bypass check
map "$bad_path_unicode$bad_path_whitespace$bad_path_dots$bad_path_encoded" $bad_path {
    default 0;
    "~*1" 1;
}

# ============================================================================
# COMBINED SECURITY CHECKS
# ============================================================================

# Combined security check variable
map "$bad_cookie_xss$bad_cookie_sqli$bad_cookie_encoding" $bad_cookie {
    default 0;
    "~*1" 1;
}

map "$bad_query_xss$bad_query_sqli$bad_query_lfi$bad_query_rfi$bad_query_cmdi" $bad_query {
    default 0;
    "~*1" 1;
}

# Final combined check (0 = safe, 1+ = block)
# Includes: cookies, query, args, headers, content-type, accept-encoding, X-Forwarded-For,
# range, smuggling, PHP, path, downgrade, hop-by-hop, cache, contamination,
# session fixation, Java injection, Shellshock, scanner/bot, HTTPoxy, H2C smuggling,
# XSLT/XXE, WAF bypass, LDAP injection, NoSQL injection, HPP, Format String
map "$bad_cookie$bad_cookie_overflow$bad_cookie_count$bad_query$bad_args$bad_header$bad_content_type$bad_accept_encoding$bad_xff$bad_range$bad_smuggling$bad_php$bad_path$bad_downgrade$bad_hopbyhop$bad_cache$bad_contamination$bad_session_fixation$bad_java$bad_shellshock$bad_scanner_bot$bad_httpoxy$bad_h2c_smuggling$bad_xslt_xxe$bad_waf_bypass$bad_ldap$bad_nosql$bad_hpp$bad_format_string" $block_request {
    default 0;
    "~*1" 1;
}

# Separate overflow check for 413 response
map $bad_cookie_overflow $block_overflow {
    default 0;
    1 1;
}
